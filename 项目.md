# 分布式流媒体

## 服务器

### 单机服务器

![image-20240221145239897](项目.assets/image-20240221145239897.png)

缺点 

服务器压力大 存储空间  用户多了后 不堪重负

Centos ubuntu 等等

改进 

存储模块 放置于别的存储集群 类似NAS的东西

![image-20240221145659932](项目.assets/image-20240221145659932.png)

### 独立服务器

![image-20240221150102916](项目.assets/image-20240221150102916.png)

应用服务器 处理与存储无关的功能

上传客户机  对资源服务器进行管理

![image-20240221150319108](项目.assets/image-20240221150319108.png)

交互性越高  时间片越短  I/O速度越快 所需时间片越长



### 分布式存储

分布式 将每个模块独立出去 不单独放置于一台机器

![image-20240221150702303](项目.assets/image-20240221150702303.png)

仲裁系统 选着某一存储主机

保证负载均衡

容灾系统 管理多级备份  热切换 主机与备份机实时同步状态 当主机损坏 则交给备份机

![image-20240221151206623](项目.assets/image-20240221151206623.png)

可以不用停机维护



![image-20240221151306356](项目.assets/image-20240221151306356.png)

跟踪服务器 实时跟踪存储服务器集群的状态

每个组间的服务器互为镜像  可以根据业务需求 将各个组放置到不同的地区



## 系统总体架构

![image-20240221152631502](项目.assets/image-20240221152631502.png)

ID服务器 产生ID 保证一个集群中的各个进程ID号等等 唯一

### 跟踪服务器

![image-20240221153407405](项目.assets/image-20240221153407405.png)

被动接受 存储服务器信息 存储服务器 服务注册

存储服务器 周期发送心跳包  跟踪服务器 周期检查心跳包



### 存储服务器和ID服务器

![image-20240221154050167](项目.assets/image-20240221154050167.png)



### 客户端

![image-20240221154307664](项目.assets/image-20240221154307664.png)



每个业务可能由一个服务器集群完成 当客户端请求某一业务处理时 需要知道对应服务器的信息

那么集群多了以后 客户机所需要维护的信息就回增多 成本增加 所以 可以类似索引一样的处理 将所有的服务器集群的信息 所能够完成的业务交给某一个专用的服务器来完成

客户机只需要与该服务器进行交互 只需要维护一个服务器的信息即可  由该服务器将所需要处理的业务分发出去



### HTTP服务器和客户机

![image-20240221155137571](项目.assets/image-20240221155137571.png)





## 报文规约  

定义一个报文 TCP是流式结构

![image-20240221155456940](项目.assets/image-20240221155456940.png)

根据固定长度的报头 来知晓该包的结构

报文格式

![image-20240221160711578](项目.assets/image-20240221160711578.png)

![image-20240221160850245](项目.assets/image-20240221160850245.png)

![image-20240221161207340](项目.assets/image-20240221161207340.png)

ID键 区分ID的种类 键值对



![image-20240221161447934](项目.assets/image-20240221161447934.png)

命令 表明响应发送源

## 库表结构

![image-20240221162749188](项目.assets/image-20240221162749188.png)

![image-20240221162857541](项目.assets/image-20240221162857541.png)

合法组名的集合

![image-20240221163032918](项目.assets/image-20240221163032918.png)

![image-20240221163242359](项目.assets/image-20240221163242359.png)

重启机器后 从数据库中的数据初始化  舍弃一段数值 保证ID唯一性

id用存储位置做键  每一个键对应一块硬盘 或者一个区 每个硬盘随机做键  用512进制来做值的部分 分成四层 每一层可以放512个文件 共有512^4个文件数



![image-20240221164301398](项目.assets/image-20240221164301398.png)

status 预留于做软删除  当删除某一文件时 将其改为1 逻辑删除 不允许用户访问 若用户想要恢复则转换为0即可

![image-20240221164716116](项目.assets/image-20240221164716116.png)

## 开发环境

![image-20240221165018035](项目.assets/image-20240221165018035.png)

![image-20240221165319392](项目.assets/image-20240221165319392.png)



redis 内存级别的数据库

![image-20240221165631767](项目.assets/image-20240221165631767.png)

![image-20240221165827838](项目.assets/image-20240221165827838.png)

![image-20240221165851567](项目.assets/image-20240221165851567.png)





![image-20240221165903867](项目.assets/image-20240221165903867.png)

网络框架

![image-20240221165927368](项目.assets/image-20240221165927368.png)

![image-20240221170225095](项目.assets/image-20240221170225095.png)



项目结构

![image-20240221170251219](项目.assets/image-20240221170251219.png)



![image-20240221170435810](项目.assets/image-20240221170435810.png)

![image-20240221170455264](项目.assets/image-20240221170455264.png)



![image-20240221170506550](项目.assets/image-20240221170506550.png)

![image-20240221170520436](项目.assets/image-20240221170520436.png)



![image-20240221170716428](项目.assets/image-20240221170716428.png)

![image-20240221171014742](项目.assets/image-20240221171014742.png)

## 代码编写

### 公共模块（宏定义 数据类型）

![image-20240221175052208](项目.assets/image-20240221175052208.png)

**types.h**

```c++
//公共模块
//定义所有模块 用到的宏 数据类型

#pragma once //头文件卫士 防止被多重定义

#include <netinet/in.h> //网络编程

//函数返回值 宏
#define OK            0 //成功
#define ERROR        -1 //本地错误 内存分配错误……
#define SOCKET_ERROR -2 //网络通信错误 
#define STATUS_ERROR -3 //服务器状态异常

//缓存 宏 对数据库的优化 前缀 类似名字空间
#define TRACKER_REDIS_PREFIX  "tracker" //跟踪服务器Redis前缀
#define STORAGE_REDIS_PREFIX  "storage" //存储服务器Redis前缀
//
//存储服务器状态 
//
typedef enum storage_status
{
  STORAGE_STATUS_OFFLINE,//离线 
  STORAGE_STATUS_ONLINE,//在线 存储服务器刚启动时 发送给跟踪服务器
  STORAGE_STATUS_ACTIVE//活动 收到心跳包的时候 
} storage_status_t; //定义枚举类型
//
//存储服务器加入 信息
//
#define STORAGE_VERSION_MAX   6   //版本号最大字符数
#define STORAGE_GROUPNAME_MAX 16  //每个存储服务器的组名的最大字符数
#define STORAGE_HOSTNAME_MAX  128 //主机名最大字符数
#define STORAGE_ADDR_MAX      16  //IP地址最大字符数

typedef struct storage_join //存储服务器加入到跟踪服务器中
{
  char      sj_version[STORAGE_VERSION_MAX + 1];     //版本号字段
  char      sj_groupname[STORAGE_GROUPNAME_MAX + 1]; //组名
  char      sj_hostname[STORAGE_HOSTNAME_MAX+1];     //主机名
  in_port_t sj_port;                                 //存储服务器端口号
  time_t    sj_stime;                                //启动时间
  time_t    sj_jtime;                                //加入时间
} storage_join_t;                                    //存储服务器加入

typedef struct storage_info
{

  char                sj_version[STORAGE_VERSION_MAX + 1];     //版本号字段
  char                sj_hostname[STORAGE_HOSTNAME_MAX+1];     //主机名
  in_port_t           sj_port;                                 //存储服务器端口号
  char                sj_addr[STORAGE_ADDR_MAX+1];             //端口号
  time_t              sj_stime;                                //启动时间
  time_t              sj_jtime;                                //加入时间
  time_t              sj_btime;                                //发送心跳时间
  storage_status_t    si_status;                               //状态
} storage_info_t;                                              //存储服务器信息
//
//ID键值对
//
#define ID_KEY_MAX 64 //键最大字符数

typedef struct id_pair
{
  char id_key[ID_KEY_MAX+1]; //键
  long id_value;             //值
  int id_offset;             //偏移量
} id_pair_t;                 //ID键值对
//
//存储服务器读写磁盘文件缓冲区
//
#define STORAGE_RCVWR_SIZE (512 * 1024) //接收写入缓冲区字节数大小
#define STORAGE_RDSND_SIZE (512 * 1024) //读取发送缓冲区字节数大小
```

> g++ -c types.h 编译头文件  得到一个.gch文件

**proto.h**

![image-20240221175925575](项目.assets/image-20240221175925575.png)

```c++
//公共模块
//定义报文规约有关的宏和数据类型
//
#pragma once

#include "types.h"
//
//请求报文
// |包体长度|命令|状态|   |包体|
// |    8  | 1  |  1 |   |包体长度|
//
#define BODYLEN_SIZE 8 //包体长度字节数
#define COMMAND_SIZE 1 //命令字节数
#define STATUS_SIZE  1 //状态字节数
#define HEADLEN (BODYLEN_SIZE + COMMAND_SIZE + STATUS_SIZE)
//
//错误报文
// |包体长度|命令|状态|错误号|错误描述|
// |8      | 1  | 1 | 2    | <=1024|
//
#define ERROR_NUMB_SIZE 2    //错误号字节数
#define ERROR_DESC_SIZE 1024 //错误描述最大字节数 含空字符
//
// | 包体长度|命令|状态|应用ID|用户ID|文件ID|
// | 8      | 1  | 1 | 16   | 256  | 128  |
//
#define APPID_SIZE  16  //应用ID最大字符串 含结束符
#define USERID_SIZE 256 //用户ID最大字节数 含结束符
#define FILEID_SIZE 128 //文件ID最大字符数 含空字符
//
//存储服务器加入包和心跳包
//
typedef struct storage_join_body
{
  char sjb_version[STORAGE_VERSION_MAX+1];     //版本
  char sjb_groupname[STORAGE_GROUPNAME_MAX+1]; //组名
  char sjb_hostname[STORAGE_HOSTNAME_MAX+1];   //主机名
  char sjb_port[sizeof(in_port_t)];            //端口号 不直接使用in_port_t 防止内存对齐 插入空字节
  char sjb_stime[sizeof(time_t)];              //启动时间
  char sjb_jtime[sizeof(time_t)];              //加入时间
} storage_join_body_t;                         //存储服务器加入包体
//
//心跳包
//
typedef struct storage_beat_body
{
  char sbb_groupname[STORAGE_GROUPNAME_MAX+1]; //组名
  char sbb_hostname[STORAGE_HOSTNAME_MAX+1];   //主机名
} storage_beat_body_t;                         //存储服务器心跳包包体
//
//追踪服务器命令
//
#define CMD_TRACKER_JOIN   10 //存储服务器向跟踪服务器发送加入包
#define CMD_TRACKER_BEAT   11 //心跳包
#define CMD_TRACKER_SADDRS 12 //客户机从跟踪服务器获取存储服务器地址
#define CMD_TRACKER_GROUPS 13 //获取组列表
//
//心跳服务器
//
#define CMD_ID_GET 40 //存储服务器从ID服务器获取ID
//
//存储服务器
//
#define CMD_STORAGE_UPLOAD 70   //客户向存储服务器上传
#define CMD_STORAGE_FILESIZE 71 //获得服务器上文件大小
#define CMD_STORAGE_DOWNLOAD 72 //下载文件
#define CMD_STORAGE_DELETE 73   //删除服务器上的文件
//
//服务器应答命令 反应响应发送源
//
#define CMD_TRACKER_REPLY 100 //跟踪服务器应答
#define CMD_ID_REPLY      101 //ID服务器
#define CMD_STORAGE_REPLY 102 //存储服务器应答

```

> gcc -c proto.h 

**util.h**

```c++
//公共模块
//声明实用函数
//
#pragma once

#include <string>
#include <vector>

//long long 主机序转网络序
void llton(long long ll, char* n);
//long long 网络序转主机序
long long ntoll(char const* n);

// long 主机序转网络序
void lton(long l, char* n);
//long 网络序转主机序
long longntol(char const* n);

// long 主机序转网络序
void lton(short s, char* n);
//long 网络序转主机序
short longntol(char const* n);

//字符串合法性验证 只允许英文字符和数字
int valid(char const* str);

//以;为分割符 将长串拆分为多个子串
int split(char const* str, std::vector<std:string>& substrs);

```

> g++ -c util.h

**util.cpp**

```c++
//公共模块
//定义几个实用函数

#include <string.h>
#include "types.h"
#include "util.h"


//long long 主机序转网络序
void llton(long long ll, char* n)
{
  for (size_t i = 0; i < sizeof(ll); ++i)
  {
    n[i] = ll >> (sizeof(ll) -i -1) * 8;
  }
}
//long long 网络序转主机序
long long ntoll(char const* n)
{ 
  long long ll;
  for (size_t i = 0; i < sizeof(ll); ++i)
  {
    ll =(long long)(unsigned char)n[i] << (sizeof(ll) -i -1) * 8;
  }
  return ll;
}
// long 主机序转网络序
void lton(long l, char* n)
{
  for (size_t i = 0; i < sizeof(ll); ++i)
  {
    n[i] = l >> (sizeof(l) -i -1) * 8;
  }
}
//long 网络序转主机序
long ntol(char const* n)
{
  long l = 0;
  for (size_t i = 0; i < sizeof(l); ++i)
  {
    l =(long long)(unsigned char)n[i] << (sizeof(l) -i -1) * 8;
  }
  return l;
}

// long 主机序转网络序
void ston(short s, char* n)
{
  for (size_t i = 0; i < sizeof(s); ++i)
  {
    n[i] = s >> (sizeof(s) -i -1) * 8;
  }
}
// 网络序转主机序
short ntos(char const* n)
{
  long long s;
  for (size_t i = 0; i < sizeof(s); ++i)
  {
    s =(short)(unsigned char)n[i] << (sizeof(ll) -i -1) * 8;
  }
  return s;
}

//字符串合法性验证 只允许英文字符和数字
int valid(char const* str)
{
  if(!str)
    return ERROR;
  size_t len = strlen(str);
  if(!len) //空串
    return ERROR;
  for(size_t i = 0; i < len; ++i)
  {
    if(!(('a' <= str[i] && str[i] <= 'z')||('A' <= str[i] && str[i] <= 'Z')||('0' <= str[i] && str[i] <= '9')))
      return ERROR;
  } 
  return OK;
}

//以;为分割符 将长串拆分为多个子串
int split(char const* str, std::vector<std:string>& substrs)
{
	if(!str) return ERROR;
  
  size_t len = strlen(str);
  if (!len) return ERROR;
  char* buf = new char[len+1];
  strcpy(buf, str);
  
  char const* sep = ";";
  for(char* substr = strtok(buf, sep); substr;substr = strtok(NULL, sep))
  {
    substrs.push_back(substr);
  }
  delete[] buf;
  return 0;
}


```

> g++ -c **util.cpp**

### 跟踪服务器

![image-20240222153429103](项目.assets/image-20240222153429103.png)

**globals.h**

```c++
//跟踪服务器
//声明全局变量
//
#pragma once

#include <vector>
#include <string>
#include <map>
#include <list>
#include <lib_acl.hpp>
#include "01_type.h"
//
//配置信息 由运维根据配置信息自行调整
//
extern char* cfg_appids; 						 // 应用ID表 应用服务列表
extern char* cfg_maddrs; 						 // MySQL地址表
extern char* cfg_raddrs; 						 // Redis地址表
extern acl::master_str_tbl cfg_str[]; // 字符串配置表

//配置项
extern int cfg_interval;              // 存储服务器状态检查间隔秒数
extern int cfg_mtimeout;              // MySQL读写超时
extern int cfg_maxconns;              // Redis连接池 最大连接数
extern int cfg_ctimeout;              //Redis连接超时
extern int cfg_rtimeout;              //Redis读写超时
extern int cfg_ktimeout;              //Redis创建键值对时的延迟所需时间
extern acl::master_int_tbl cfg_int[]; //整形配置表

extern std::vector<std::string> g_appids; // 将地址表拆分放入向量中
extern std::vector<std::string> g_maddrs; //MySQL地址表
extern std::vector<std::string> g_raddrs; //Redis地址表
extern acl::redis_client_pool* g_rconns;  //Redis连接池 动态创建内存
extern std::string g_hostname;            //主机名
extern std::map<std::string, std::list<storage_info_t> > g_groups; //组表
//维护各个组的信息
extern pthread_mutex_t g_mutex; //互斥锁 保证组表同一时间写入组表

```

> gcc -c globals.h -I acl-lib  “-I 找到acl”

**globals.cpp**

```c++
//跟踪服务器
//声明全局变量
//
#include "globals.h"


//
//配置信息 由运维根据配置信息自行调整
//
char* cfg_appids; 						 // 应用ID表 应用服务列表
char* cfg_maddrs; 						 // MySQL地址表
char* cfg_raddrs; 						 // Redis地址表
acl::master_str_tbl cfg_str[] 
= { 
    {"tnv_apps_id", "tnvideo",        &cfg_appids}, 
    {"mysql_addrs", "127.0.0.1",      &cfg_maddrs}, 
    {"redis_addrs", "127.0.0.1:6379", &cfg_raddrs}, 
    {0, 0, 0} 
  };// 字符串配置表

//配置项
int cfg_interval;              // 存储服务器状态检查间隔秒数
int cfg_mtimeout;              // MySQL读写超时
int cfg_maxconns;              // Redis连接池 最大连接数
int cfg_ctimeout;              //Redis连接超时
int cfg_rtimeout;              //Redis读写超时
int cfg_ktimeout;              //Redis创建键值对时的延迟所需时间
acl::master_int_tbl cfg_int[] 
 = {
  {"check_active_interval", 120, &cfg_interval, 0, 0},
  {"mysql_rw_timeout",      30,  &cfg_mtimeout, 0, 0},
  {"redis_max_conn_num",    600, &cfg_maxconns, 0, 0},
  {"redis_conn_timeout",    10,  &cfg_ctimeout, 0, 0}，
  {"redis_rw_timeout",      10,  &cfg_rtimeout, 0, 0},
  {"redis_key_timeout",     60,  &cfg_rtimeout, 0, 0},
  {0，                      0，  0，             0,0}
}; //整形配置表 初始化
std::vector<std::string> g_appids; // 将地址表拆分放入向量中
std::vector<std::string> g_maddrs; //MySQL地址表
std::vector<std::string> g_raddrs; //Redis地址表
acl::redis_client_pool* g_rconns;  //Redis连接池 动态创建内存
std::string g_hostname;            //主机名
std::map<std::string, std::list<storage_info_t> > g_groups; //组表
//维护各个组的信息
pthread_mutex_t g_mutex = PTHREAD_MUTEX_INITIALIZER; //互斥锁 保证组表同一时间写入组表
```

> gcc -c globals.cpp -I acl-lib  “-I 找到acl”

**cache.h**

```C++
//跟踪服务器
//声明缓存类
//
#pragma once

#include <lib_acl.hpp>
//
// 缓存类 缓存中有一个小型数据库
//
class cache_c {
  public:
  //根据键获取值
  int get(char const* key, acl::string& value) const;//查
  
  //设定指定键的值 增 与 改
  int set(char const* key, char const* value, int timeout = -1) const;
  
  //删除键值对
  int del(char const* key) const;
}
```

> g++ -c cache.h

**cache.cpp**

```c++
//跟踪服务器
//实现缓存类
//

#include "globals.h"
#include "cache.h"

//根据键获取值
int get(char const* key, acl::string& value) const//查
{ 
  //构造键
  acl::string track_key;
  tracker_key.format("%s:%s", TRACKER_REDIS_PREFIX, key); //格式化键
  
  //检查redis 连接池
	if (!g_rconns)
  {
		logger_warn("redis connection pool is null, key:%s", 
                track_key.c_str());
  	return ERROR;
  }
    
  //从连接池中获取一个Redis连接
	acl::redis_client* rconn = (acl::redis_client*)g_rconns->peek();
  if (!ronn)
  {
		logger_warn("peek redis connection fail, key:%s",
                tracker_key.c_str());
    return ERROR;
  }
  //持有此连接的redis对象 作为redis 客户机
  acl::redis redis;
  redis.set_client(rconn);
  
  //redis客户机 设定指定键值
  if(timeout < 0) timeout = cfg_ktimeout;
  if(!redis.setex(tracker_key.cstr(), value, timeout))
  {
    logger_warn("set cache fail, key:%s, valuee:%s, timeout:%d",
                tracker_key.c_str(), value, timeout);
    g_rcons->put(rconn, false);
    return ERROR;
  }

  logger("get cache ok, key:%s , value: %s, timeout: %d", 
         tracker_key,c_str(), 
         value.c_str());
  g_rconns->put(rconn, true);
  
  return OK;
}
//设定指定键的值 增 与 改
int set(char const* key, 
        char const* value, 
        int timeout) const
{
  
   //构造键
  acl::string track_key;
  tracker_key.format("%s:%s", TRACKER_REDIS_PREFIX, key); //格式化键
  
  //检查redis 连接池
	if (!g_rconns)
  {
		logger_warn("redis connection pool is null, key:%s", 
                track_key.c_str());
  	return ERROR;
  }
    
  //从连接池中获取一个Redis连接
	acl::redis_client* rconn = (acl::redis_client*)g_rconns->peek();
  if (!ronn)
  {
		logger_warn("peek redis connection fail, key:%s",
                tracker_key.c_str());
    return ERROR;
  }
  //持有此连接的redis对象 作为redis 客户机
  acl::redis redis;
  redis.set_client(rconn);
  
  //redis客户机 根据键获得值
  if(!redis.get(tracker_key.cstr(), value))
  {
    logger_warn("get cache fail, key:%s", tracker_key.c_str());
    g_rcons->put(rconn, false);
    return ERROR;
  }
  //检查空值
  if( value.emptey())
  {
    logger_warn("value is empty, key: %s", track_key.c_str());
    g_rconns->put(rconn, false);
    return ERROR;
  }
  logger("get cache ok, key:%s , value: %s", 
         tracker_key,c_str(), 
         value.c_str());
  g_rconns->put(rconn, true);
  
  
  
  return OK;
}



//删除键值对
int del(char const* key) const
{
  
   //构造键
  acl::string track_key;
  tracker_key.format("%s:%s", TRACKER_REDIS_PREFIX, key); //格式化键
  
  //检查redis 连接池
	if (!g_rconns)
  {
		logger_warn("redis connection pool is null, key:%s", 
                track_key.c_str());
  	return ERROR;
  }
    
  //从连接池中获取一个Redis连接
	acl::redis_client* rconn = (acl::redis_client*)g_rconns->peek();
  if (!ronn)
  {
		logger_warn("peek redis connection fail, key:%s",
                tracker_key.c_str());
    return ERROR;
  }
  //持有此连接的redis对象 作为redis 客户机
  acl::redis redis;
  redis.set_client(rconn);
  
  //redis客户机 删除键值对
  if(!redis.del_one(tracker_key.cstr()))
  {
    logger_warn("delete cache fail, key:%s", tracker_key.c_str());
    g_rcons->put(rconn, false);
    return ERROR;
  }
 
  logger("delete cache ok, key:%s ", 
         tracker_key,c_str(), 
         );
  g_rconns->put(rconn, true);
  
  
  return OK;
}

```

**db.h**

```c++
//跟踪服务器
//声明数据库访问类
//
#pragma once

#include <string>
#include <vector>
#include <mysql.h>
//
//数据库访问类
//
class db_c
{
	public:
  //构造函数
  db_c(void);
  //析构函数 资源释放
  ~db_c(void);
  //连接数据库
  int connect(void); //固定数据库
  //根据用户ID获取对应的组名
  int get(char const* userid, std::string& groupname) const;
  //设置用户ID和组名的关系
  int set(char const* appid,
          char const* userid, 
          char const* groupname) const;
  //获取全部的组名
  int get(std::vector<std::string>& groupnames) const;
	private:
  // MySQL对象 通过该对象调用对应的MySQL对象
  MYSQL* m_mysql; 
};
```

> mysql_config —–cflags 获得mysql.h
>
> g++ -c db.h  -I…… \`mysql_config —–cflags\`
>
> shell 中将`` 所包含的内容视作一个命令 将该命令作为字符串拼接

**db.cpp**

```c++
//跟踪服务器
//实现数据库访问类
//
#include "globals.h"
#include "cache.h"
#include "db.h"
//
//数据库访问类
//
//构造函数
db_c::db_c(void)
  :m_mysql(mysql_init(NULL)) //创建MySQL对象
  {
    if(!m_mysql)
    {
      logger_error("create dao fail %s", mysql_error(m_mysql));
    }
  }
//析构函数 资源释放
db_c::~db_c(void)
{
  //销毁MySQL对象
  if(!m_mysql)
  {
    mysql_close(m_musql);
    m_mysql = NULL;
  }
}
//连接数据库
int db_c::connect(void) //固定数据库
{
  MYSQL* mysql = m_mysql;
  //遍历MySQL地址表 尝试连接数据库
  for(std::vector<std::string>::const_iterator maddr = 
      g_maddrs.begin();maddr != g_maddrs.end(); ++maddr)
  {
    if(
      m_mysql = mysql_real_connect(mysql, mmaddr->c_str(),"root","123456",
                                   0, 
                                   NULL,
                                   0)
    )   
    {
      return OK;
    }
  }
  logger_error("connect database fail: %s", 
               mysql_error(m_mysql = mysql));
  return ERROR;
}
//根据用户ID获取对应的组名
int db_c::get(char const* userid, std::string& groupname) const
{
  return OK;
}
//设置用户ID和组名的关系
int db_c::set(char const* appid,
              char const* userid, 
              char const* groupname) const
{
  return OK;
}
//获取全部的组名
int db_c::get(std::vector<std::string>& groupnames) const
{
  return OK;
}

```

